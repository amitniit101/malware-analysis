Decorators work by wrapping the original function with another function, allowing you to add pre-processing or post-processing logic. Here's the basic structure of a decorator:
def log_function_call(original_function):
    def wrapper(*args, **kwargs):
        print(f'Calling {original_function.__name__} with args: {args}, kwargs: {kwargs}')
        result = original_function(*args, **kwargs)
        print(f'{original_function.__name__} returned: {result}')
        return result
    return wrapper

@log_function_call
def add(a, b):
    return a + b

result = add(5, 3)

#### genrators
Generators in Python are a way to create iterators, which are objects that can be iterated (looped) over. They provide a convenient way to create iterable sequences of values, especially for large or infinite data sets, without the need to store them in memory all at once. Generators are created using functions or expressions with the yield keyword.

def simple_generator():
    yield 1
    yield 2
    yield 3

# Creating a generator object
gen = simple_generator()

# Iterating over the generator
for value in gen:
    print(value)

gen = (x for x in range(10) if x % 2 == 0)

def infinite_counter():
    i = 0
    while True:
        yield i
        i += 1

#### Sort a dict without using keyword
my_dict = {'c': 3, 'a': 1, 'b': 2, 'd': 4}

# Convert dictionary items into a list of tuples (key, value)
items = list(my_dict.items())

# Custom sorting function based on keys (in ascending order)
def custom_sort(item):
    return item[0]

# Sort the list of tuples based on the custom sort function
items.sort(key=custom_sort)

# Reconstruct a new dictionary from the sorted list
sorted_dict = {key: value for key, value in items}

print(sorted_dict)

### with using keyword sort according to values
my_dict = {'c': 3, 'a': 1, 'b': 2, 'd': 4}
sorted_dict = {k: v for k, v in sorted(my_dict.items(), key=lambda item: item[1])}

### sort according to keys
my_dict = {'c': 3, 'a': 1, 'b': 2, 'd': 4}
sorted_dict = {k: my_dict[k] for k in sorted(my_dict)}

#### sort list without using keyword
my_list = ["abc", "cde", "xyz", "mno", "ijk"]
n = len(my_list)

for i in range(n):
    for j in range(0, n - i - 1):
        if my_list[j] > my_list[j + 1]:
            my_list[j], my_list[j + 1] = my_list[j + 1], my_list[j]

print(my_list)

### sort list with keywords
my_list = ["abc", "cde", "xyz", "mno", "ijk"]
sorted_list = sorted(my_list)

### sort list with keywords
my_list = ["abc", "cde", "xyz", "mno", "ijk"]
my_list.sort()

### flatten list without using keyword
def flatten_list(nested_list):
    flat_list = []
    
    for item in nested_list:
        if isinstance(item, list):
            # If the item is a list, recursively flatten it
            flat_list.extend(flatten_list(item))
        else:
            # If the item is not a list, add it to the flat list
            flat_list.append(item)
    
    return flat_list

# Example usage
nested_list = [1, [2, 3], [4, [5, 6]], 7]
flattened = flatten_list(nested_list)
print(flattened)


#### sort the list using lambda
my_list = [{'name': 'John', 'age': 30},
           {'name': 'Alice', 'age': 25},
           {'name': 'Bob', 'age': 35}]

# Sort the list of dictionaries based on the 'age' key using a lambda function
sorted_list = sorted(my_list, key=lambda x: x['age'])

# Print the sorted list
print(sorted_list)

#### filter using lambda
my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Filter the list to get even numbers using a lambda function
filtered_list = list(filter(lambda x: x % 2 == 0, my_list))


##### Flask api
from flask import Flask, request, jsonify
import logging
import os
from flask_cors import CORS

app = Flask(__name__)
CORS(app)  # Enable Cross-Origin Resource Sharing (CORS)

# Configure Logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Dummy User Authentication (Replace with your actual authentication logic)
def authenticate(username, password):
    if username == 'user' and password == 'password':
        return True
    return False

# Directory to store uploaded photos
UPLOAD_FOLDER = 'uploads'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# Create the upload folder if it doesn't exist
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

@app.route('/api/posts', methods=['POST'])
def create_post():
    try:
        # Dummy Authentication Check (Replace with your actual authentication)
        if not request.authorization or not authenticate(request.authorization.username, request.authorization.password):
            return 'Authentication failed', 401

        # Handle request to create a post
        data = request.form
        title = data['title']
        content = data['content']
        photo = request.files['photo']

        # Save the post data to a file (you can replace this with a database operation)
        with open(f'posts/{title}.txt', 'w') as post_file:
            post_file.write(content)

        # Save the uploaded photo
        if photo:
            photo.save(os.path.join(app.config['UPLOAD_FOLDER'], photo.filename))

        # Simulated response with a post_id
        response_data = {'post_id': 123}
        return jsonify(response_data), 201
    except Exception as e:
        logger.error('Error creating post: %s', str(e))
        return 'Internal Server Error', 500

@app.errorhandler(400)
def bad_request(error):
    return 'Bad Request', 400

if __name__ == '__main__':
    app.run(debug=True)

####  open api 
openapi: 3.0.0
info:
  title: Blogging API
  version: 1.0
paths:
  /api/posts:
    post:
      summary: Create a Post with Photo
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                username:
                  type: string
                password:
                  type: string
                title:
                  type: string
                content:
                  type: string
                photo:
                  type: string
                  format: binary
      responses:
        '201':
          description: Post created successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  post_id:
                    type: integer
        '400':
          description: Bad request


### in SQL find out third highest salary
SELECT DISTINCT Salary
FROM Employees
ORDER BY Salary DESC
LIMIT 2, 1;

#### From each department
SELECT department, 
       MAX(person_name) AS person_name, 
       MAX(salary) AS second_highest_salary
FROM (
    SELECT department, 
           person_name, 
           salary,
           DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank
    FROM employees
) ranked
WHERE rank = 2
GROUP BY department;

### Connect database using python
pip install mysql-connector-python

import mysql.connector

# Replace with your database details
db_config = {
    "host": "your_mysql_server",
    "user": "your_username",
    "password": "your_password",
    "database": "your_database_name"
}

# Establish the database connection
conn = mysql.connector.connect(**db_config)

For PostgreSQL, you can use the psycopg2 library. Install it using pip:
# Replace with your database details
conn = psycopg2.connect(
    host="your_postgresql_server",
    user="your_username",
    password="your_password",
    database="your_database_name"
)

import pyodbc

# Replace with your database connection string
conn = pyodbc.connect('Driver={SQL Server};Server=your_sql_server;Database=your_database;UID=your_username;PWD=your_password')
